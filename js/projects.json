[
  {
    "title": "Occlusion-Aware UAV Routing",
    "description": "A predictive routing metric that guides UAVs through urban canyons by anticipating signal loss from buildings.",
    "bullets": [
      "Reduces routing outages by over 85%.",
      "Integrates a probabilistic Line-of-Sight model into OLSR.",
      "Validated in high-fidelity ns-3 simulations."
    ],
    "tech": "C++, Python, ns-3, OLSR",
    "focus": ["Robotics", "Networking"],
    "details": "# Occlusion-Aware UAV Routing\n\n**Tagline:** A predictive routing metric that enables reliable UAV communication in urban canyons by proactively navigating around building blockages.\n\n---\n\n### Overview\n\nIn urban environments, standard UAV routing protocols often fail due to high mobility and frequent signal loss from buildings. This project introduces an occlusion-aware routing metric that anticipates these disruptions, allowing for stable and reliable communication. By integrating a probabilistic Line-of-Sight (LoS) model into the OLSR protocol, the system can intelligently select routes that are less likely to be obstructed.\n\n**My Role:** I designed and implemented the core routing metric, developed the ns-3 simulation environment to model urban environments, and conducted a thorough performance evaluation.\n\n---\n\n### Technical Deep Dive\n\n**Tech Stack:** C++, Python, ns-3, OLSR\n\n**Key Features:**\n*   **Predictive LoS Model:** Uses UAV GPS data and a city map to predict the probability of a stable link in the near future (0.5s horizon).\n*   **Probabilistic Routing Metric:** Instead of a binary \"connected/disconnected\" state, links are weighted by their LoS probability, leading to more stable routes.\n*   **OLSR Integration:** The metric is integrated into the OLSR routing protocol, a standard for ad-hoc networks, allowing for easy adoption.\n\n**Challenges & Solutions:**\nThe main challenge was creating a lightweight predictive model that could run on board the UAVs without significant overhead. The solution involved using a simple kinematic prediction for short time horizons and a pre-loaded city map, which proved sufficient to achieve a dramatic improvement in routing stability without requiring heavy computation.\n\n---\n\n### Outcome & Reflection\n\nThe new metric **reduced routing outages from over 40% to just 5.6%** in a large-scale urban simulation. This project was a great lesson in the importance of context-aware design; by making the networking layer aware of the physical world, we were able to build a far more robust system."
  },
  {
    "title": "AI-Powered UAV Swarm Coverage",
    "description": "A multi-agent DRL system that enables UAVs to intelligently position themselves for optimal ground coverage in urban areas.",
    "bullets": [
      "Doubles user coverage compared to traditional methods.",
      "Uses attention-based coordination for decentralized execution.",
      "Balances coverage with energy efficiency."
    ],
    "tech": "Python, PyTorch, PettingZoo, DRL",
    "focus": ["Robotics", "AI/ML"],
    "details": "# AI-Powered UAV Swarm Coverage\n\n**Tagline:** An intelligent, multi-agent DRL system that enables UAV swarms to dynamically provide communication coverage in dense urban environments.\n\n---\n\n### Overview\n\nWhen ground communication infrastructure is unavailable, a swarm of UAVs can act as a mobile cell tower network. This project uses deep reinforcement learning to train UAVs to automatically position themselves for optimal coverage of ground users, while navigating obstacles and minimizing energy consumption. The system is designed for decentralized execution, making it scalable and robust.\n\n**My Role:** I developed the multi-agent DRL solution, including the design of the CNN-based spatial perception module and the attention-based coordination mechanism. I also set up the simulation environment and benchmarked the results.\n\n---\n\n### Technical Deep Dive\n\n**Tech Stack:** Python, PyTorch, PettingZoo, DRL, CNNs, Attention Mechanisms\n\n**Key Features:**\n*   **Multi-Agent DRL:** Uses a centralized training, decentralized execution model with PPO for stable and scalable learning.\n*   **Spatial Perception:** A CNN-based module processes obstacle maps, user distributions, and coverage staleness, allowing the UAVs to 'see' their environment.\n*   **Attention-Based Coordination:** A multi-head attention mechanism allows UAVs to weigh the importance of information from their neighbors, leading to implicit coordination.\n\n**Challenges & Solutions:**\nThe key challenge was the high-dimensional, partially observable nature of the problem. By using a powerful DRL framework and carefully designing the observation space and reward function, the system was able to learn complex, cooperative behaviors that would be difficult to hand-engineer.\n\n---\n\n### Outcome & Reflection\n\nThe system achieved **more than double the user coverage** compared to baseline methods, while also being more energy-efficient. This project demonstrated the power of DRL for solving complex, multi-agent robotics problems. It also highlighted the importance of good reward shaping in achieving desired emergent behaviors."
  },
  {
    "title": "Autonomous Racing Trajectory Optimization",
    "description": "A nonlinear optimizer that generates high-speed, dynamically feasible trajectories for autonomous slalom racing.",
    "bullets": [
      "Jointly optimizes vehicle speed, path, and curvature.",
      "Supports online replanning for newly detected obstacles.",
      "Validated on a full-scale autonomous vehicle."
    ],
    "tech": "Python, SciPy, ROS, Nonlinear Optimization",
    "focus": ["Robotics", "Optimization"],
    "details": "# Autonomous Racing Trajectory Optimization\n\n**Tagline:** A nonlinear trajectory optimizer that generates fast, smooth, and safe paths for autonomous slalom racing.\n\n---\n\n### Overview\n\nThis project focuses on the core problem of motion planning for autonomous racing. I designed a trajectory generation module that uses nonlinear optimization to find the fastest possible path through a slalom course, while respecting the vehicle's dynamic limits. The system is capable of online replanning, allowing it to adapt to newly detected course markers.\n\n**My Role:** I designed and implemented the entire trajectory optimization pipeline, from the formulation of the optimization problem to the integration with the vehicle's ROS-based control system.\n\n---\n\n### Technical Deep Dive\n\n**Tech Stack:** Python, SciPy, ROS, Nonlinear Optimization\n\n**Key Features:**\n*   **Nonlinear Optimization:** The problem is formulated as a constrained nonlinear optimization problem, jointly optimizing over the vehicle's position, heading, curvature, and speed.\n*   **Velocity as an Optimization Variable:** Unlike many planners that fix velocity profiles, this system treats velocity as a variable, allowing for smoother and faster trajectories.\n*   **Online Replanning:** The planner is fast enough to support online replanning and trajectory stitching, ensuring smooth transitions as the vehicle's understanding of the course evolves.\n\n**Challenges & Solutions:**\nOne challenge was ensuring the convergence and feasibility of the nonlinear solver in real-time. By using soft constraints for waypoints and the terminal state, the solver was able to find good solutions much more reliably than with hard constraints.\n\n---\n\n### Outcome & Reflection\n\nThe planner was successfully validated in simulation and on a full-scale GEM autonomous vehicle. This project was a deep dive into the mathematics and software engineering of motion planning, and it reinforced the importance of good problem formulation in optimization."
  },
  {
    "title": "Custom TCP-like Protocol from Scratch",
    "description": "A reliable transport protocol built on top of UDP, implementing congestion control, loss recovery, and fairness.",
    "bullets": [
      "Achieves high bandwidth utilization and fair sharing.",
      "TCP-friendly, coexisting with standard TCP flows.",
      "Built and tested in C on Linux."
    ],
    "tech": "C, UDP, Sockets, Linux tc",
    "focus": ["Networking", "Systems"],
    "details": "# Custom TCP-like Protocol from Scratch\n\n**Tagline:** A reliable, congestion-aware transport protocol built from the ground up on top of UDP.\n\n---\n\n### Overview\n\nThis project involved building a TCP-like reliable transport protocol from scratch in C. The goal was to implement the core mechanisms that make TCP work, including reliability (guaranteed, in-order delivery), and congestion control (adapting to network conditions and sharing bandwidth fairly).\n\n**My Role:** I designed and implemented the entire protocol, including the sender and receiver logic, packet sequencing, acknowledgments, retransmissions, and congestion control mechanisms.\n\n---\n\n### Technical Deep Dive\n\n**Tech Stack:** C, UDP Sockets, Linux `tc`\n\n**Key Features:**\n*   **Reliable Delivery:** Implemented using packet sequencing, acknowledgments, and a retransmission timer.\n*   **Congestion Control:** A congestion control mechanism was implemented to ensure the protocol is a good network citizen, fairly sharing bandwidth with competing flows.\n*   **TCP Friendliness:** The protocol was designed to coexist with standard TCP flows, achieving comparable throughput under contention.\n\n**Challenges & Solutions:**\nThe most challenging part was tuning the congestion control algorithm to be both efficient and fair. I used the Linux `tc` (traffic control) tool to create a network environment with controlled packet loss and delay, which was invaluable for testing and debugging.\n\n---\n\n### Outcome & Reflection\n\nThe final implementation successfully transferred files reliably, achieved high bandwidth utilization, and demonstrated fair sharing with both other instances of itself and with standard TCP. This project provided a deep, practical understanding of how transport protocols work under the hood."
  },
  {
    "title": "Real-Time Pet Localization System",
    "description": "A low-cost indoor tracking system using BLE beacons and an HMM-based algorithm to find pets in a home.",
    "bullets": [
      "Achieves over 90% room-level accuracy.",
      "Visualizes real-time location on a web dashboard.",
      "Built with ESP32s, a Raspberry Pi, and a Flask backend."
    ],
    "tech": "Python, C/C++, Flask, BLE, HMM",
    "focus": ["IoT", "Embedded"],
    "details": "# Real-Time Pet Localization System\n\n**Tagline:** A low-cost, room-scale indoor localization system to keep track of your pets.\n\n---\n\n### Overview\n\nThis project is a complete, end-to-end IoT system for localizing pets within a home. It uses BLE beacons attached to the pets' collars, which are detected by ESP32 receivers placed in each room. A central Raspberry Pi server aggregates the data, runs a localization algorithm, and hosts a web dashboard to display the pet's current location and historical data.\n\n**My Role:** I designed the system architecture, programmed the ESP32 receivers, and implemented the Python backend, including the HMM-based localization algorithm and the Flask web application.\n\n---\n\n### Technical Deep Dive\n\n**Tech Stack:** Python, C/C++, Flask, BLE, HMM, Raspberry Pi, ESP32\n\n**Key Features:**\n*   **HMM-based Localization:** To improve accuracy, I used a Hidden Markov Model (HMM) to model the pet's movement between rooms. This temporal model improved accuracy from 87.7% to 90.9% compared to just using raw RSSI values.\n*   **Staggered Transmission:** To avoid Wi-Fi collisions from the ESP32 receivers, I implemented a simple staggered transmission schedule.\n*   **Web Dashboard:** A lightweight Flask web app provides a real-time view of the pet's location on a floor plan, along with a pie chart of time spent in each room.\n\n**Challenges & Solutions:**\nSignal strength (RSSI) from BLE beacons is notoriously noisy. The combination of RSSI averaging and an HMM was effective at filtering this noise and producing a stable, accurate location estimate.\n\n---\n\n### Outcome & Reflection\n\nThe system provides reliable, real-time room-level tracking and offers interesting behavioral insights. This was a fun, full-stack project that covered everything from embedded C++ on the ESP32 to a Python backend and a web frontend."
  },
  {
    "title": "Federated Learning Platform Enhancements",
    "description": "A suite of features for a federated learning platform, including model uploading, resource monitoring, and data visualization.",
    "bullets": [
      "Contributed to a scheduler that doubled training speed.",
      "Published at ICLR 2024.",
      "Integrated with AWS, Globus Auth, and Globus Compute."
    ],
    "tech": "Python, PyTorch, AWS, Globus",
    "focus": ["AI/ML", "Distributed Systems"],
    "details": "# Federated Learning Platform Enhancements\n\n**Tagline:** A suite of usability and observability features for a cross-silo federated learning platform.\n\n---\n\n### Overview\n\nThis work was part of a larger research project to build a user-friendly and powerful platform for federated learning. My contributions focused on making the platform easier to use and providing better insight into the training process. I implemented features for uploading custom models, monitoring client resources, and visualizing data distributions, all of which are crucial for real-world federated learning.\n\n**My Role:** I was a key contributor to the platform's frontend and backend, implementing several user-facing features, building monitoring dashboards, and integrating with services like Globus and AWS.\n\n---\n\n### Technical Deep Dive\n\n**Tech Stack:** Python, PyTorch, AWS (ECS, S3, DynamoDB), Globus Compute, Globus Auth\n\n**Key Features:**\n*   **GitHub & Hugging Face Integration:** Allowed users to directly import model architectures and pre-trained weights from GitHub and Hugging Face.\n*   **Client Resource Monitoring:** Built dashboards to track CPU, GPU, and memory usage across heterogeneous clients, helping to diagnose performance bottlenecks.\n*   **Data Distribution Visualization:** Implemented tools to expose data heterogeneity across clients, a key challenge in federated learning.\n*   **Semi-Asynchronous Scheduler:** Contributed to the design of a novel scheduler that speeds up training by 2-3x on heterogeneous clients, work that was accepted at ICLR 2024.\n\n**Challenges & Solutions:**\nA major challenge in federated learning is dealing with the \"messiness\" of real-world distributed systems. By building robust monitoring and visualization tools, we empowered researchers to better understand and debug their experiments.\n\n---\n\n### Outcome & Reflection\n\nMy contributions significantly improved the usability and observability of the platform and were part of a research paper accepted at **ICLR 2024**. This project was a great experience in building a complex, distributed system for a real research community."
  }
]